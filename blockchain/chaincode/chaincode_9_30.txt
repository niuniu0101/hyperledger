package main

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/hyperledger/fabric-contract-api-go/v2/contractapi"
)

// MultiRingManager 是管理多个一致性哈希环的智能合约
type MultiRingManager struct {
	contractapi.Contract
}

// allRingsKey 是一个固定的键，用于在世界状态中存储所有环的数据
const allRingsKey = "all_rings_data_key"

// numberOfRings 控制初始化时创建的哈希环数量
const numberOfRings = 6

// ServerNode 代表一个服务器节点及其状态
type ServerNode struct {
	ServerName     string `json:"serverName"`
	MerkleRootHash string `json:"merkleRootHash"`
}

// AllRingsContainer 是存储在世界状态中的顶层结构
type AllRingsContainer struct {
	Rings map[string][]ServerNode `json:"rings"`
}

// InitLedger 初始化账本，创建指定数量的空环
// func (s *MultiRingManager) InitLedger(ctx contractapi.TransactionContextInterface) error {
// 	log.Printf("Initializing the ledger with %d empty rings", numberOfRings)

// 	// 创建初始的复合结构
// 	initialData := AllRingsContainer{
// 		Rings: make(map[string][]ServerNode),
// 	}

// 	// 根据numberOfRings创建指定数量的环
// 	for i := 0; i < numberOfRings; i++ {
// 		ringID := fmt.Sprintf("ring%d", i)
// 		initialData.Rings[ringID] = []ServerNode{}
// 	}

// 	initialDataJSON, err := json.Marshal(initialData)
// 	if err != nil {
// 		return fmt.Errorf("failed to marshal initial rings data: %w", err)
// 	}

//		return ctx.GetStub().PutState(allRingsKey, initialDataJSON)
//	}
//
// InitLedger 初始化账本，创建指定数量的空环，并在 ring0 中添加一个默认节点
func (s *MultiRingManager) InitLedger(ctx contractapi.TransactionContextInterface) error {
	log.Printf("Initializing the ledger with %d empty rings", numberOfRings)

	// 1. 创建初始的复合结构
	initialData := AllRingsContainer{
		Rings: make(map[string][]ServerNode),
	}

	// 2. 根据numberOfRings创建指定数量的环
	for i := 0; i < numberOfRings; i++ {
		ringID := fmt.Sprintf("ring%d", i)
		initialData.Rings[ringID] = []ServerNode{}
	}

	// 3. 【新增逻辑】在第一个环 (ring0) 中添加一个默认节点
	const initialRingID = "ring0"
	if _, ok := initialData.Rings[initialRingID]; ok {
		initialNode := ServerNode{
			ServerName:     "Initial_Node_0",
			MerkleRootHash: "0xInitialHashPlaceholder", // 默认哈希值
		}
		initialData.Rings[initialRingID] = append(initialData.Rings[initialRingID], initialNode)
		log.Printf("Added default node '%s' to '%s'", initialNode.ServerName, initialRingID)
	}

	// 4. 序列化并写入账本
	initialDataJSON, err := json.Marshal(initialData)
	if err != nil {
		return fmt.Errorf("failed to marshal initial rings data: %w", err)
	}

	return ctx.GetStub().PutState(allRingsKey, initialDataJSON)
}

// AddServerNode 添加一个新的服务器节点到指定的环中
func (s *MultiRingManager) AddServerNode(ctx contractapi.TransactionContextInterface, ringID string, serverName string, merkleRootHash string) error {
	fmt.Printf("Attempting to add server node '%s' to ring '%s'", serverName, ringID)

	// 1. 读取整个复合对象
	allRingsJSON, err := ctx.GetStub().GetState(allRingsKey)
	if err != nil {
		return fmt.Errorf("failed to read from world state: %w", err)
	}
	if allRingsJSON == nil {
		return fmt.Errorf("rings data not found. Please initialize the ledger first")
	}

	var container AllRingsContainer
	if err := json.Unmarshal(allRingsJSON, &container); err != nil {
		return fmt.Errorf("failed to unmarshal rings container: %w", err)
	}

	// 2. 在内存中修改
	targetRing, ok := container.Rings[ringID]
	if !ok {
		return fmt.Errorf("ring '%s' does not exist", ringID)
	}

	for _, node := range targetRing {
		if node.ServerName == serverName {
			return fmt.Errorf("server node '%s' already exists in ring '%s'", serverName, ringID)
		}
	}

	newNode := ServerNode{
		ServerName:     serverName,
		MerkleRootHash: merkleRootHash,
	}
	container.Rings[ringID] = append(targetRing, newNode)

	// 3. 将修改后的整个对象写回
	updatedRingsJSON, err := json.Marshal(container)
	if err != nil {
		return fmt.Errorf("failed to marshal updated rings container: %w", err)
	}

	return ctx.GetStub().PutState(allRingsKey, updatedRingsJSON)
}

// RemoveServerNode 从指定的环中移除一个服务器节点
func (s *MultiRingManager) RemoveServerNode(ctx contractapi.TransactionContextInterface, ringID string, serverName string) error {
	log.Printf("Attempting to remove server node '%s' from ring '%s'", serverName, ringID)

	allRingsJSON, err := ctx.GetStub().GetState(allRingsKey)
	if err != nil {
		return fmt.Errorf("failed to read from world state: %w", err)
	}
	if allRingsJSON == nil {
		return fmt.Errorf("rings data not found")
	}

	var container AllRingsContainer
	if err := json.Unmarshal(allRingsJSON, &container); err != nil {
		return fmt.Errorf("failed to unmarshal rings container: %w", err)
	}

	targetRing, ok := container.Rings[ringID]
	if !ok {
		return fmt.Errorf("ring '%s' does not exist", ringID)
	}

	found := false
	for i, node := range targetRing {
		if node.ServerName == serverName {
			container.Rings[ringID] = append(targetRing[:i], targetRing[i+1:]...)
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("server node '%s' not found in ring '%s'", serverName, ringID)
	}

	updatedRingsJSON, err := json.Marshal(container)
	if err != nil {
		return fmt.Errorf("failed to marshal updated rings container: %w", err)
	}

	return ctx.GetStub().PutState(allRingsKey, updatedRingsJSON)
}

// UpdateMerkleRoot 更新指定环中某个服务器节点的默克尔树根哈希
func (s *MultiRingManager) UpdateMerkleRoot(ctx contractapi.TransactionContextInterface, ringID string, serverName string, newMerkleRootHash string) error {
	log.Printf("Attempting to update merkle root for server '%s' in ring '%s'", serverName, ringID)

	allRingsJSON, err := ctx.GetStub().GetState(allRingsKey)
	if err != nil {
		return fmt.Errorf("failed to read from world state: %w", err)
	}
	if allRingsJSON == nil {
		return fmt.Errorf("rings data not found")
	}

	var container AllRingsContainer
	if err := json.Unmarshal(allRingsJSON, &container); err != nil {
		return fmt.Errorf("failed to unmarshal rings container: %w", err)
	}

	targetRing, ok := container.Rings[ringID]
	if !ok {
		return fmt.Errorf("ring '%s' does not exist", ringID)
	}

	found := false
	for i := range targetRing {
		if targetRing[i].ServerName == serverName {
			targetRing[i].MerkleRootHash = newMerkleRootHash
			found = true
			break
		}
	}

	if !found {
		return fmt.Errorf("server node '%s' not found in ring '%s'", serverName, ringID)
	}

	// 更新map中的切片
	container.Rings[ringID] = targetRing

	updatedRingsJSON, err := json.Marshal(container)
	if err != nil {
		return fmt.Errorf("failed to marshal updated rings container: %w", err)
	}

	return ctx.GetStub().PutState(allRingsKey, updatedRingsJSON)
}

// GetAllRingsData 查询并返回所有环及其节点信息
func (s *MultiRingManager) GetAllRingsData(ctx contractapi.TransactionContextInterface) (*AllRingsContainer, error) {
	log.Println("Querying for all rings data.")

	allRingsJSON, err := ctx.GetStub().GetState(allRingsKey)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %w", err)
	}
	if allRingsJSON == nil {
		log.Println("No rings data found, returning empty structure.")
		return &AllRingsContainer{Rings: make(map[string][]ServerNode)}, nil
	}

	var container AllRingsContainer
	if err := json.Unmarshal(allRingsJSON, &container); err != nil {
		return nil, fmt.Errorf("failed to unmarshal rings container: %w", err)
	}

	return &container, nil
}

func main() {
	chaincode, err := contractapi.NewChaincode(&MultiRingManager{})
	if err != nil {
		log.Panicf("Error creating multi-ring manager chaincode: %v", err)
	}

	if err := chaincode.Start(); err != nil {
		log.Panicf("Error starting multi-ring manager chaincode: %v", err)
	}
}
