// ...existing code...
package main

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/hyperledger/client/pkg/fabric"
	"github.com/hyperledger/client/pkg/models"
	"github.com/hyperledger/client/pkg/network"
	"github.com/hyperledger/client/pkg/pipeline"
	"github.com/hyperledger/consistent"
)

// usepipeline: 1=流水线模式，0=单文件模式
var usepipeline int

var ringServerMap = map[string]string{
	"ring0": "8.208.81.144:8080",
	"ring1": "47.237.16.182:8080",
	"ring2": "47.91.124.37:8080",
	"ring3": "47.91.124.37:8080",
	"ring4": "80.220.202.165:8080",
	"ring5": "80.220.202.165:8080",
}

type fileRoute struct {
	Node       string
	RingID     string
	ServerAddr string
	FileHash   uint64
	ShortName  string
}

func truncateFileName(name string) string {
	if len(name) > 16 {
		return name[:16]
	}
	return name
}

func buildFileRoute(hrm *consistent.HashRingManager, fileName string) (*fileRoute, error) {
	hash := sha256.Sum256([]byte(fileName))
	fileHash := binary.BigEndian.Uint64(hash[:8])
	ringID := fmt.Sprintf("ring%d", fileHash%4)
	serverAddr, ok := ringServerMap[ringID]
	if !ok {
		return nil, fmt.Errorf("环 %s 未配置服务器地址", ringID)
	}
	shortName := truncateFileName(fileName)
	nodeName := locateFileNode(hrm, ringID, shortName)
	if nodeName == "" {
		return nil, fmt.Errorf("环 %s 未找到节点", ringID)
	}
	return &fileRoute{
		Node:       nodeName,
		RingID:     ringID,
		ServerAddr: serverAddr,
		FileHash:   fileHash,
		ShortName:  shortName,
	}, nil
}

func addNodesToBlockchain(fabricClient *fabric.FabricClient) {
	for i := 0; i < 40; i++ {
		serverName := fmt.Sprintf("node%d", i)
		for {
			err := fabricClient.AddServerNode(fmt.Sprintf("ring%d", i%4), serverName, "")

			if err != nil {
				log.Printf("添加节点失败: %s, err: %v", serverName, err)
				continue
			}
			break
		}
		fmt.Printf("add %s to ring%d\n", serverName, i%4)
	}
	for i := 40; i < 60; i++ {
		serverName := fmt.Sprintf("node%d", i)
		for {
			err := fabricClient.AddServerNode(fmt.Sprintf("ring%d", 4+i%2), serverName, "")

			if err != nil {
				log.Printf("添加节点失败: %s, err: %v", serverName, err)
				continue
			}
			break
		}
		fmt.Printf("add %s to ring%d\n", serverName, i%2+4)
	}
}

// 构建本地一致性哈希环，返回 HashRingManager
func buildLocalHashRing(fabricClient *fabric.FabricClient) (*consistent.HashRingManager, error) {
	data, err := fabricClient.GetAllRingsData()
	if err != nil {
		return nil, fmt.Errorf("获取区块链哈希环失败: %v", err)
	}
	var container models.AllRingsContainer
	if err := json.Unmarshal(data, &container); err != nil {
		return nil, fmt.Errorf("解析哈希环数据失败: %v", err)
	}
	hrm := consistent.NewHashRingManager()
	hrm.BuildHashRingsFromData(&container)
	return hrm, nil
}

// 根据 ringID 和文件名，定位节点
func locateFileNode(hrm *consistent.HashRingManager, ringID, fileName string) string {
	return hrm.LocateKey(ringID, fileName)
}

// 测试客户端 locateFileNode 路由时间
func testRouteTime(hrm *consistent.HashRingManager, fileNames []string) {
	start := time.Now()
	success := 0
	for _, name := range fileNames {
		hash := sha256.Sum256([]byte(name))
		fileHash := binary.BigEndian.Uint64(hash[:8])
		ringID := fmt.Sprintf("ring%d", fileHash%4)
		shortName := truncateFileName(name)
		node := locateFileNode(hrm, ringID, shortName)
		if node != "" {
			success++
		}
	}
	dur := time.Since(start)
	if success > 0 {
		avg := dur / time.Duration(success)
		fmt.Printf("[路由测试] 总数: %d, 成功: %d, 总耗时: %v, 平均耗时: %v\n", len(fileNames), success, dur, avg)
	} else {
		fmt.Println("[路由测试] 未能成功路由任何文件名！")
	}
}

// displayRingStatus 是一个辅助函数，用于查询并打印当前所有环上的节点状态
func displayRingStatus(fabricClient *fabric.FabricClient, title string) {
	fmt.Println("---------------------------------------")
	fmt.Printf("[状态检查] %s\n", title)
	hrm, err := buildLocalHashRing(fabricClient)
	if err != nil {
		log.Fatalf("构建本地哈希环失败: %v", err)
	}

	// 遍历所有环并打印其成员
	for ringID, ring := range hrm.GetAllRings() {
		members := ring.GetMembers()
		if len(members) > 0 {
			fmt.Printf("Ring %s 上的节点: ", ringID)
			for _, node := range members {
				fmt.Printf("%s ", node.String())
			}
			fmt.Println()
		} else {
			fmt.Printf("Ring %s 上的节点: (空)\n", ringID)
		}
	}
	fmt.Println("---------------------------------------")
}

// 串行模式：逐个上传和查询文件
func runSerialMode(hrm *consistent.HashRingManager, getClient func(string) *network.TCPClient, files []os.DirEntry) {
	fmt.Println("=== 使用串行模式 ===")

	// 1. 串行上传文件
	uploadCount := 0
	fmt.Println("开始串行上传文件...")
	for _, file := range files {
		if uploadCount >= 1000 {
			break
		}
		if file.IsDir() {
			continue
		}

		filePath := filepath.Join("files", file.Name())
		data, err := os.ReadFile(filePath)
		if err != nil {
			log.Printf("读取文件失败: %s, err: %v", filePath, err)
			continue
		}

		route, err := buildFileRoute(hrm, file.Name())
		if err != nil {
			log.Printf("串行上传路由失败: %s, err: %v", file.Name(), err)
			continue
		}

		client := getClient(route.ServerAddr)
		if client == nil {
			log.Printf("串行上传: 未获取到服务器客户端 %s", route.ServerAddr)
			continue
		}

		err = client.UploadFile(route.Node, route.ShortName, route.FileHash, data)
		if err != nil {
			log.Printf("串行上传失败: %s -> %s (%s), err: %v", route.ShortName, route.Node, route.ServerAddr, err)
		} else {
			log.Printf("串行上传成功: %s -> %s (%s)", route.ShortName, route.Node, route.ServerAddr)
		}
		uploadCount++
	}

	// 2. 串行查询文件
	receiveDir := "file_receive"
	if err := os.MkdirAll(receiveDir, 0755); err != nil {
		log.Fatalf("创建接收目录失败: %v", err)
	}

	queryCount := 0
	fmt.Println("开始串行查询文件...")
	for _, queryFile := range files {
		if queryCount >= 1000 {
			break
		}
		if queryFile.IsDir() {
			continue
		}

		route, err := buildFileRoute(hrm, queryFile.Name())
		if err != nil {
			log.Printf("串行查询路由失败: %s, err: %v", queryFile.Name(), err)
			continue
		}

		client := getClient(route.ServerAddr)
		if client == nil {
			log.Printf("串行查询: 未获取到服务器客户端 %s", route.ServerAddr)
			continue
		}

		result, err := client.QueryFile(route.Node, route.FileHash)
		if err != nil {
			log.Printf("串行查询失败: %s, err: %v", queryFile.Name(), err)
			continue
		}

		// 检查返回内容是否为错误信息
		if len(result) < 8 || (len(result) >= 5 && string(result[:5]) == "ERROR") {
			log.Printf("服务端返回错误: %s, msg: %s", queryFile.Name(), string(result))
			continue
		}

		outPath := filepath.Join(receiveDir, queryFile.Name())
		if err := os.WriteFile(outPath, result, 0644); err != nil {
			log.Printf("写入文件失败: %s, err: %v", outPath, err)
		} else {
			log.Printf("串行查询并写入成功: %s", outPath)
		}
		queryCount++
	}
}

// 流水线模式：使用流水线批量处理上传和查询
func runPipelineMode(hrm *consistent.HashRingManager, getClient func(string) *network.TCPClient, files []os.DirEntry) {
	fmt.Println("=== 使用流水线模式 ===")

	hashFunc := func(fileName string) (string, uint64, string, string) {
		route, err := buildFileRoute(hrm, fileName)
		if err != nil {
			log.Printf("[流水线] 路由失败: %s, err: %v", fileName, err)
			return "", 0, "", ""
		}
		return route.Node, route.FileHash, route.ShortName, route.ServerAddr
	}

	// 1. 流水线批量上传
	uploadPipeline := pipeline.NewClientPipeline(
		hashFunc,
		func(server, node string, tasks []*pipeline.FileTask) {
			if server == "" || node == "" {
				return
			}
			client := getClient(server)
			if client == nil {
				log.Printf("[流水线] 无法获取服务器客户端: %s", server)
				return
			}
			for _, t := range tasks {
				shortName := t.ShortName
				if shortName == "" {
					shortName = truncateFileName(t.FileName)
				}
				err := client.UploadFile(node, shortName, t.FileHash, t.Data)
				if err != nil {
					log.Printf("[流水线] 上传失败: %s -> %s (%s), err: %v", shortName, node, server, err)
				} else {
					log.Printf("[流水线] 上传成功: %s -> %s (%s)", shortName, node, server)
				}
			}
		},
		5,
	)

	uploadCount := 0
	fmt.Println("开始流水线上传文件...")
	for _, file := range files {
		if uploadCount >= 1000 {
			break
		}
		if file.IsDir() {
			continue
		}

		filePath := filepath.Join("files", file.Name())
		data, err := os.ReadFile(filePath)
		if err != nil {
			log.Printf("[流水线] 读取文件失败: %s, err: %v", filePath, err)
			continue
		}

		uploadPipeline.PushWorkload(file.Name(), data)
		uploadCount++
	}
	uploadPipeline.FlushAll()
	fmt.Println("等待上传流水线完成...")
	uploadPipeline.Wait()
	fmt.Println("上传流水线已完成!")

	// 2. 流水线批量查询
	receiveDir := "file_receive"
	if err := os.MkdirAll(receiveDir, 0755); err != nil {
		log.Fatalf("创建接收目录失败: %v", err)
	}

	queryPipeline := pipeline.NewClientPipeline(
		hashFunc,
		func(server, node string, tasks []*pipeline.FileTask) {
			if server == "" || node == "" {
				return
			}
			client := getClient(server)
			if client == nil {
				log.Printf("[流水线] 无法获取服务器客户端: %s", server)
				return
			}
			for _, t := range tasks {
				result, err := client.QueryFile(node, t.FileHash)
				if err != nil {
					log.Printf("[流水线] 查询失败: %s -> %s (%s), err: %v", t.FileName, node, server, err)
					continue
				}

				if len(result) < 8 || (len(result) >= 5 && string(result[:5]) == "ERROR") {
					log.Printf("[流水线] 服务端返回错误: %s, msg: %s", t.FileName, string(result))
					continue
				}

				outPath := filepath.Join(receiveDir, t.FileName)
				if err := os.WriteFile(outPath, result, 0644); err != nil {
					log.Printf("[流水线] 写入文件失败: %s, err: %v", outPath, err)
				} else {
					log.Printf("[流水线] 查询并写入成功: %s", outPath)
				}
			}
		},
		5,
	)

	queryCount := 0
	fmt.Println("开始流水线查询文件...")
	for _, file := range files {
		if queryCount >= 1000 {
			break
		}
		if file.IsDir() {
			continue
		}

		queryPipeline.PushWorkload(file.Name(), nil)
		queryCount++
	}
	queryPipeline.FlushAll()
	fmt.Println("等待查询流水线完成...")
	queryPipeline.Wait()
	fmt.Println("查询流水线已完成!")
}

func main() {
	flag.IntVar(&usepipeline, "usepipeline", 0, "1=使用流水线模式, 0=单文件模式")
	flag.Parse()

	fabricClient, err := fabric.InitFabricClientFromFlags()
	if err != nil {
		log.Fatalf("FabricClient 初始化失败: %v", err)
	}
	defer fabricClient.Close()

	if err := fabricClient.InitLedger(); err != nil {
		log.Printf("账本初始化失败（可忽略已初始化错误）: %v", err)
	}

	displayRingStatus(fabricClient, "账本初始化后的初始状态")
	addNodesToBlockchain(fabricClient)
	hrm, err := buildLocalHashRing(fabricClient)
	if err != nil {
		log.Fatalf("构建本地哈希环失败: %v", err)
	}
	for ringID, ring := range hrm.GetAllRings() {
		fmt.Printf("Ring %s 上的节点: ", ringID)
		for _, node := range ring.GetMembers() {
			fmt.Printf("%s ", node.String())
		}
		fmt.Println()
	}

	clientCache := make(map[string]*network.TCPClient)
	getClient := func(serverAddr string) *network.TCPClient {
		if serverAddr == "" {
			return nil
		}
		if c, ok := clientCache[serverAddr]; ok {
			return c
		}
		c := network.NewTCPClient(serverAddr)
		clientCache[serverAddr] = c
		return c
	}

	dir := "files"

	files, err := os.ReadDir(dir)
	if err != nil {
		log.Fatalf("读取目录失败: %v", err)
	}

	if usepipeline == 1 {
		runPipelineMode(hrm, getClient, files)
	} else {
		runSerialMode(hrm, getClient, files)
	}

	testNames := make([]string, 10000)
	for i := 0; i < 10000; i++ {
		testNames[i] = fmt.Sprintf("file_%d.txt", i)
	}
	testRouteTime(hrm, testNames)

}
